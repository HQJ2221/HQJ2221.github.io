[{"title":"Algorithm_Design","path":"/2024/06/10/Algorithm-Design/","content":"Algorithm Design and AnalysisI. Induction, Recursion and ContradictionBefore Class: **Q: **What is Algorithm ? **A1: **A procedure to solve a mathemetical problem.Sometimes repetition of an operation should be involved, so we have to make sure that an algorithm can terminate at last. A2: An algorithm is a finite, definite, effective procedure, with some input and some output. (“Great algorithms are the poetry of computation.”) Def. An algorithm is an ordered set of unambiguous, executable steps that defines a terminating process. Algorithmic Paradigms (算法范式) Greedy Divide-and-conquer Dynamic programming Network flow Randomized algorithms Intractability Coping with intractabilit Reduction (约化，优化) About reduction: If the solution of problem A can also solve problem B, we can say that problem A can be reduced to problem B P-Problem —- Problems that can be solved in a time complexity of polynomial. (E.g. $O(n^2)$) NP-Problem —- If a solution of the problem can be proved (验证解或可猜测出解) in polynomial time complexity, we call this problem Non-deterministic Polynomial (NP) Problem. NP-Hard Problem —- For problem A, if all the NP-Problem can be reduced to it , we call A an NP-Hard Problem. In this class, we won't talk about NP-Hard Problem ! i. InductionDef. Mathematical induction (数学归纳) is a technique for showing that a statement P(n) is true for all natural numbers n, or for some infinite subset of the natural numbers. A proof by induction has the following outline : Claim: $P(n)$ is true for all positive integers $n$. Proof: We’ll use induction on $n$. Base: We need to show that $P(1)$ is true. Induction: Suppose that $P(n)$ is true for $n &#x3D; 1, 2, . . . , k−1$. We need to show that $P(k)$ is true. Key Point of Induction: Prove $P(k+1)$ to be true if $P(k)$ is true. ii. Recursion A recursive definition always has two parts Base case(s) Recursive formula E.g. $g(1)&#x3D;1$ $g(n)&#x3D;g(n-1)+1,\\ \\ \\text{for all}\\ \\ n \\leq 2$ How to find the closed forms of recursive formula ?The simplest technique for finding closed forms is called unrolling. E.g. Function $T:N \\to Z$ defined by$$T(1)&#x3D;1\\T(n)&#x3D;2T(n-1)+3,\\ \\forall n \\leq 2$$ We first enclose the recursive formula :$$T(n)&#x3D;2^k T(n-k)+3\\sum_{i&#x3D;0}^{k-1}{2^i}$$ Then it can be simplified (using induction) to :$$T(n)&#x3D;2^k T(n-k)+3(2^{n-1}-1)&#x3D;2^{n+1}-3$$ We always use the base case(s) in the induction step, so be ware of base case(s). iii. Contradiction (反证) Contradiction is more frequently use but less convincing and harder. In proof by contradiction, we show that a claim $P$ is true by showing that its negation $ eg P$ leads to a contradiction. II. Stable Matching E.g. We use “Matching Residents to Hospitals” to explain about Stable Matching. Goal. Given a set of preferences among hospitals and medical school students, design a self-reinforcing admissions process. Unstable pair: applicant x and hospital y are unstable if: x prefers y to its assigned hospital. y prefers x to one of its admitted students. Stable assignment: Assignment with no unstable pairs. Natural and desirable condition. Individual self-interest will prevent any applicant&#x2F;hospital deal from being made. Stable Matching Problem Goal. Given n men and n women, find a “suitable” matching. Pic 1. 最佳匹配问题 Perfect Matching—— one to one relationship Each man gets exactly one woman. Each woman gets exactly one man. Stability Given a Perfect Matching $S$, if there exists a group of man and women $(m,w)$ holds all that: $(m,w) ot\\in S$ $m$ more like $w$ than his current mate $w$ more like $m$ than her current mate Then we say that group $(m,w)$ is an Unstable factor Stable Matching: Perfect matching without unstable pairs Stable matching problem: Given the preference lists(e.g. Pic 1) of n men and n women, find a stable matching if one exists Q: How to solve this problem ? A: Using Propose-And-Reject Algorithm.Also called Gale-Shapley Algorithm. It guarantees to find a stable matching for any problem instance. Summerize in Chinese: 从男方根据好感度降序选择，若女方无配对或对现有配对好感度较低，则男方配对成功。 1234567891011Initialize each person to be free.while (some man is free and hasn&#x27;t proposed to every woman) &#123;\tChoose such a man m\tw = 1st woman on m&#x27;s list to whom m has not yet proposed\tif (w is free) assign m and w to be engaged\telse if (w prefers m to her fiancé sub_m) assign m and w to be engaged, and sub_m to be free\telse w rejects m&#125; Comment: What a Brute Force!!! Time complexity: $T(n)&#x3D;O(n^2)$ at most. Q: How to implement the algorithm more efficiently? A: Exchange space with time. Representing men and women. Assume men are named $1, …, n$. Assume women are named $1’, …, n’$. Engagements. Maintain a list of free men, e.g., in a queue. Maintain two arrays wife[m], and husband[w]. – set entry to 0 if unmatched – if m matched to w then wife[m] = w and husband[w] = m Men proposing. For each man, maintain a list of women, ordered by preference. Maintain an array count[m] that counts the number of proposals made by man m. Women rejecting&#x2F;accepting. Does woman $w$ prefer man $m$ to man $m’$? For each woman, create inverse of preference list of men. Constant time access for each query after $O(n)$ preprocessing Def. Man $m$ is a valid partner of woman $w$ if there exists some stable matching in which they are matched (1) Man-optimal assignment. Each man receives best valid partner. Claim. All executions of GS yield man-optimal assignment, which is a stable matching. Pic 2. Proof of the Claim 注解：$S^*$ 匹配中，假设 M1 (男) 没有匹配到最好的，则表示他被拒绝了 (假设 W1 拒绝了他)。 于是可以推断在匹配 $S^*$ 中，M1 被拒绝后，W1 (女) 和另一个男性 M2 匹配了。即认为 W1 选择 M2 优先于选择 M1 。 再假设另一个稳定匹配 $S$ 中，M1 和W1 匹配了，并假设 M2 和另一位女性 W2 匹配了。 因此推导在匹配 $S^*$ 中，当 W1 拒绝 M1 时，M2 还没被拒绝过 (或者说他还没配对，然后把 W1 抢走了) ，根据男方先选的原则，M2 选择 W1 优先于选择 W2 。 然后我们惊奇地发现，匹配 $S^$ 中出现了不稳定因素 (W1 和 M2 即将私奔！) 。所以用反证法证明了原假设错误。 总结：先由原配对 $S$ 给出反证假设匹配 $S^*$ (不是男方最优) ，通过求证 $S^*$ 并非稳定匹配，证明通过GS算法得到的稳定匹配一定是男方最优的。（必须理清“是男方最优解”和“是稳定匹配”在此算法内的逻辑关系！） Pic 3. Proof in Chinese (2) Woman-pessimal assignment. Each woman receives worst valid partner. Claim. GS finds woman-pessimal stable matching $S^*$ (对女方则是“非最优解”) III. Graph You have learnt Graph on DSAA, now have a further study on it. Pic 4. Applications of Graph Problems of Graph s - t connectivity problem (两点连通问题) Given two node s and t, is there a pathbetween s and t? s-t shortest path problem Given two node s and t, what is the length of the shortest path between s and t? BFS intuition (广搜) Thm. For each $i$, $L_i$ consists of all nodes at distance exactly $i$ from $s$. There is a path from $s$ to $t$ iff $t$ appears in some layer. → Pic 5. BFS for Graph Connected Component (连通分量问题) Thm. Upon termination, $R$ is the connected component containing $s$. BFS &#x3D; explore in order of distance from $s$. DFS &#x3D; explore in a different way. Bipartite GraphDef. An undirected graph $G &#x3D; (V, E)$ is bipartite if the nodes can be colored red or blue such that every edge has one red and one blue end. (e.g. stable matching) Many graph problems become: – easier if the underlying graph is bipartite (matching) – tractable (易处理的) if the underlying graph is bipartite (independent set) Before attempting to design an algorithm, we need to understand structure of bipartite graphs. Lemma 1. If a graph $G$ is bipartite, it cannot contain an odd length cycle. Lemma 2. Let $G$ be a connected graph, and let $L_0 , \\cdots, L_k$ be the layers produced by BFS starting at node $s$. Exactly one of the following holds. ( i ) No edge of $G$ joins two nodes of the same layer, and $G$ is bipartite ( ii ) An edge of $G$ joins two nodes of the same layer, and $G$ contains an odd-length cycle (and hence is not bipartite). Pic 6. Why Lemma 2 holds ? Proof : Layer 代表了距离根节点最近的距离，由此推出不存在跨层序的边。 又：如果同层序的两个节点相连，则它们的父辈节点中最终会存在一个令其相交的单个节点，在此之前它们经过的同层节点必定是偶数个 (2个) ，由此推出会形成一个奇数环。 由 Lemma 1 可知，形成奇数节点环时，不是 bipartite 的。 Strong ConnectivityDef. Node $u$ and $v$ are mutually reachable if there is a path from $u$ to $v$ and also a path from $v$ to $u$. Def. A graph is strongly connected if every pair of nodes is mutually reachable. Theorem: Can determine if G is strongly connected in $O(m + n)$ time 做法：对正反图分别跑一次 BFS 即可（DSAA 学过） IV. Greedy AlgorithmInterval SchedulingRecall : Pic 7. Interval Scheduling Greedy algorithm. Consider jobs in increasing order of finish time. Take each job provided it’s compatible with the ones already taken. 12345678Sort jobs by finish times so that f1 &lt;= f2 &lt;= ... &lt;= fnA &lt;- Ufor j &lt;- 1 to n &#123;\tif(job j compatible to A) A.add(j)&#125;return A How to get schedule then ? Record job $\\text{j}^*$ that was last added to $A$ Job $\\text{j}$ is compatible with $A$ if $\\text{s}{\\text{j}} \\ge \\text{f}{\\text{j}^*}$ (to prove greedy algo’ is optimal) Interval Partitioning But it can be reduced to 3 Pic 8. Interval Partitioning Solution: Still Greedy Algorithm 12345678910Sort intervals by Starting Time so that s1&lt;=s2&lt;= ...&lt;=sn.d &lt;- 0\t/* classroom number */for j &lt;- 1 to n &#123;\tif (lecture j is compatible with some classroom k) schedule lecture j in classroom k\telse allocate a new classroom d + 1 schedule lecture j in classroom d + 1 d &lt;- d + 1&#125; TC: $O(n\\log n)$ Scheduling to Minimize LatenessPic 9. Minimizing Lateness 12345678Sort n jobs by deadline so that d1&lt;=d2&lt;=...&lt;=dnt &lt;- 0for j = 1 to n\tAssign job j to interval [t, t + t_j]\ts_j &lt;- t\tf_j &lt;- t + t_j\tt &lt;- t + t_joutput intervals[s_j, f_j] 注：图 9 中不是最优解，最优解应该是按照算法跑，从 1 到 6 安排，最后只有做任务 4 时产生了 1 的延时。 思想重点：这里会发现一个很有意思的思想——当确定使用贪心算法能解决问题时，我们需要根据每个元素的不同特征对比，选出那个最主要的特征用于排序并进行贪心。 Optimal Offline Caching (Connected to Computer Organization) Cache with capacity to store $k$ items. Sequence of $m$ item requests $d_1,d_2 , …, d_m$. Cache hit: item already in cache when requested. Cache miss: item not already in cache when requested: must bring requested item into cache, and evict (丢弃) some existing item, if full. Goal. Eviction schedule that minimizes number of cache misses. Farthest-In-Future —— best way to solve Def. Evict item in the cache that is not requested until farthest in the future. Pic 10. FF Algorithm Thm. FF is an optimal eviction schedule. Prove it ? Reduced Eviction Schedules Def. A reduced schedule is a schedule that only inserts an item into the cache in a step in which that item is requested. Proof of “FF generates reduced schedule” Suppose $S$ brings $d$ into the cache at time $t$, without a request. Let $c$ be the item $S$ evicts when it brings $d$ into the cache. Case 1. d evicted at time t&#39;, before next request for d. Case 2. d requested at time t&#39; before d is evicted. Case 3. d is not in the cache; S_FF evicts e, and S evicts f != e Minimum Spanning TreePic 11. MST Cut : Let S be any subset of nodes, and let e be the min cost edge with exactly one endpoint in S. Then the MST contains e Cutset. A cut S is a subset of nodes. The corresponding cutset D is the subset of edges with exactly one endpoint in S. Cycle : Let C be any cycle, and let f be the max cost edge belonging to C. Then the MST does not contain f Clustering k-clustering. Divide objects into k non-empty groups. Spacing. Min distance between any pair of points in different clusters. Pic 12. k-Clustering Problem Pic 13. Solution Huffman Codes Representing Prefix Codes using Binary Tree Only leaf of the tree can represent prefix codes Def. The average bits per letter of a prefix code c is the sum over all symbols of its frequency times the number of bits of its encoding:$$\\text{ABL}(c)&#x3D;\\sum_{x\\in S} f_{x} \\cdot \\abs{c(x)}$$ If we representing prefix codes using binary trees, we calculate $ABL$ of the tree as: $$\\text{ABL}(T)&#x3D;\\sum_{x\\in S} f_{x} \\cdot \\text{depth}_T(x)$$ Greedy template of Huffman Tree. Pic 14. Huffman Binary Tree 12345678910111213Huffman(S) &#123;\tif |S|=2 &#123; return tree with root and 2 leaves\t&#125; else &#123; let y and z be lowest-frequency letters in S S’ = S remove y and z from S’ insert new letter w in S’ with f_w= f_y + f_z T’ = Huffman(S’) T = add two children y and z to leaf w from T’ return T\t&#125;&#125; Analysis : V. Divide-and-Conquer We have learnt “Binary Search” and “Merge Sort” in DSAA. They both use the thought of Divide-and-Conquer. Counting InversionE.g. You and me ranked $n$ songs. Music site consults database to find people with similar tastes. Similarity metric: number of inversions between two rankings My rank: $1, 2, …, n$. Your rank: $a_1, a_2, …, a_n$ Songs $i$ and $j$ inverted if $i &lt; j$, but $a_i &gt; a_j$. Songs A B C D E Me 1 2 3 4 5 You 1 3 4 2 5 Actually we can use what we use in “merge sort” to calculate the counting inversion. If choose from the second set before the first was all chosen, that’s mean there is inversion. 12345678910Sort-and-Count(L) &#123;\tif list L has one element return 0 and the list L Divide the list into two halves A and B\t(rA, A) &lt;- Sort-and-Count(A)\t(rB, B) &lt;- Sort-and-Count(B)\t(rB, L) &lt;- Merge-and-Count(A, B)\treturn r = rA + rB + r and the sorted list L&#125; Closest Pair of PointsClosest pair. Given $n$ points in the plane, find a pair with smallest Euclidean distance between them. Can we use Divide-and-Conquer thought to solve this ? How to consider the points near the boundary ? Observation: only need to consider points within $\\delta$ of line $L$. Sort points in $2\\delta$-strip by their $y$ coordinate. Only check distances of those within 11 positions (this example) in sorted list ! Complex MultiplierFast Fourier Transform (快速傅里叶变换) Fast way to multiply and evaluate polynomials (多项式相乘问题) Fast way to convert between time-domain and frequency-domain. > Recall: > > **Fourier Theorem.** Any periodic function can be expressed as the sum of a series of sinusoids. [周期函数可以表示为正弦或余弦的级数] > > **Euler’s Identity.** $\\begin{array}{c}{{e^{j x}=\\cos x+j\\,\\sin x}};\\ \\ \\ \\ {{e^{j x}=\\cos x-j\\,\\sin x}}\\end{array}$ > ${{\\mathrm{cos}(\\,\\omega t)=\\frac{1}{2}(e^{j\\omega t}+e^{-j\\omega t})}};\\ \\ \\ {{\\mathrm{sin}(\\,\\omega t)=\\frac{1}{2\\,j}(e^{j\\omega t}-e^{-j\\omega t})}}$ About Time Domain vs. Frequency Domain E.g. For a signal : $y(t)&#x3D;{\\textstyle{\\frac{1}{2}}}\\mathrm{sin}(2\\pi\\cdot697t)+{\\textstyle{\\frac{1}{2}}}\\mathrm{sin}(2\\pi\\cdot1209t)$ About FFT Fast way to convert between time-domain and frequency-domain. Another viewpoint: Fast way to evaluate polynomials multiplications $$C({x})&#x3D;{A}({x}){B}({x})&#x3D;c_{0}+c_{1}x+c_{2}x^{2}+\\cdots+c_{k}x^{k}+\\cdots+c_{n+m-2}x^{n+m-2}\\\\text{where }\\ c_k&#x3D;\\sum_{(i,j):i+j&#x3D;k}a_i b_j$$ Two representation of polynomials: Coefficient Representation : $A(x)&#x3D;a_{0}+a_{1}x+a_{2}x^{2}+\\cdots+a_{n-1}x^{n-1}$ Evaluate costing $O(n)$ : $A(x)&#x3D;a_{0}+(x(a_{1}+x(a_{2}+\\cdots+x(a_{n-2}+x(a_{n-1}))\\cdots))$ Mutiply (convolve) costing $O(n^2)$ : $A(x)\\times B(x)&#x3D;\\sum_{i&#x3D;0}^{2n-2}c_{i}x^{i},\\ \\ \\text{ where }\\ c_{i}&#x3D;\\sum_{j&#x3D;0}^{i}!a_{j}{b}_{i-j}$ Point-Value Representation : $A(x):(x_{0},y_{0}),\\cdots,(x_{n-1},y_{n-1})$ Multiply (convolve) costing $O(n)$ : $A(x)\\times B(x):(x_{0},,y_{0}\\times z_{0}),\\dots,,(x_{2n-1},,y_{2n-1}\\times z_{2n-1})$ $2n-1$ points are needed. Evaluate costing $O(n^2)$ using Lagrange ‘s formula : $A(x)&#x3D;\\sum_{k&#x3D;0}^{n-1} y_{k}$ $\\frac{\\prod_{j eq k}(x-x_{j})}{\\prod_{j eq k}(x_{k}-x_{j})}$ So if we want a fast way to both calculate in $O(n)$ , we need a fast way to convert between c-type and pv-type. FFT Algorithm Goal. Evaluate a degree $n-1$ polynomial $A(x) &#x3D; a_0 + \\cdots + a_{n-1} x^{n-1}$ at its n-th roots of unity: $\\omega^0,\\cdots,\\omega^{n-1}$ Divide. Break up polynomial into even and odd powers : - ${{A_{\\text{even}}(x)\\ =\\ a_{0}+a_{2}x+a_{4}x^{2}+\\dots+a_{n-2}x^{n/2-1}}}$ - ${{A_{\\text{odd}}(x)\\ =\\ a_{1}+a_{3}x+a_{5}x^{2}+\\dots+a_{n-1}x^{n/2-1}}}$ - ${{A(x)\\ =A_{\\text{even}}(x^{2})+x\\,A_{\\text{odd}}(x^{2})}}$ Conquer. Evaluate $A_{\\text{even}}(x)$ and $A_{\\text{odd}}(x)$ at the $\\frac{1}{2}n$-th roots of unity : $v^0,v^1,\\cdots,v^{n&#x2F;2-1}$ Combine.$$\\begin{align*}A(\\omega^k) &amp;&#x3D; A_{\\text{even}}(v^k) + \\omega^k A_{\\text{odd}}(v^k), &amp; 0 \\leq k &lt; n&#x2F;2 \\A(\\omega^{k+\\frac{n}{2}}) &amp;&#x3D; A_{\\text{even}}(v^k) - \\omega^k A_{\\text{odd}}(v^k), &amp; 0 \\leq k &lt; n&#x2F;2\\end{align*}$$ fft is from Coefficient to Point-value. And ifft is from Point-value to Coefficient. VI. Dynamic ProgrammingGreedy. Build up a solution incrementally, myopically optimizing some local criterion. Divide-and-conquer. Break up a problem into sub-problems, solve each sub-problem independently, and combine solution to sub-problems to form solution to original problem. Dynamic programming. Break up a problem into a series of overlapping sub-problems, and build up solutions to larger and larger sub-problems Weighted Interval Problem —— Binary choiceRecall for Weighted Interval Problem Job $j$ starts at $s_j$ , finishes at $f_j$ , and has weight or value $v_j$ . Two jobs compatible if they don‘t overlap (in time). Goal: find maximum weight subset of mutually compatible jobs. Sort schedule by its finish time $f_i$ Let $p(i)&#x3D;j$ if $s_i\\ge f_j$ . (E.g. $p(8)&#x3D;6$ , $p(3)&#x3D;0$) $$ \\text{OPT}(j)=\\left\\{ \\begin{array}{c}\\begin{align} &0 &\\text{if }j=0\\\\ &\\max{\\{v_j + \\text{OPT}(p(j)) , \\text{OPT}(j-1)\\}} &\\text{otherwise}\\\\ \\end{align}\\end{array}\\right. $$ Algorithm 123456789Input: n, s1,...,sn , f1,...,fn , v1,...,vnSort jobs by finish times so that f1 &lt;= f2 &lt;= ... &lt;= fn.Compute p(1), p(2),..., p(n)Iterative-Compute-Opt &#123;\tM[0] = 0\tfor j = 1 to n M[j] = max(v_j + M[p(j)], M[j-1])&#125; Segmented Least Squares —— Multi-way choiceNotation $SSE&#x3D;\\sum_{i&#x3D;1}^{n}(y_i-ax_i-b)^2$ as Sum of Square Error $OPT(j) &#x3D;$ minimum cost for points $p_1 , p_{i+1} , . . . , p_j$ . $e(i, j) &#x3D;$ minimum sum of squares for points $p_i, p_{i+1} ,\\cdots , pj$ . $$ OPT(j)=\\left\\{\\begin{array}{l}{{0}}&{{\\mathrm{if~j=0~}}}\\\\ \\underset{{1\\le i\\le j}}\\min\\{~e(i,j)+c+O P T(i-1)\\mathrm{~}\\}&\\mathrm{otherwise}\\end{array}\\right. $$ Algorithm 1234567891011INPUT: n, p1, ..., pN, cSegmented-Least-Squares() &#123;\tM[0] = 0\tfor j &lt;- 1 to n for i &lt;- 1 to j compute the least square error e&#123;ij&#125; for the segment pi, ..., pj for j = 1 to n M[j] = min(e&#123;ij&#125; + c + M[i-1]) with 1 &lt;= i &lt;= j\treturn M[n]&#125; Runtime: $O(n^3)$ (or $O(n^2)$ by pre-computing various statistics) Knapsack Problem —— Adding a new variable Given n objects and a \"knapsack.\" Item i weighs w(i) > 0 kilograms and has value v(i) > 0. Knapsack has capacity of W kilograms. Goal: fill knapsack so as to maximize total value. Using Dynamic Programming : Def. $OPT(i,w)&#x3D;\\max \\text{~profit subset of items } 1,\\cdots,i \\color{red}\\text{ with weight limit w}$ Case 1 : $OPT(i,w)$ doesn’t select item $i$ OPT selects best of ${ 1, 2, \\cdots, i-1 }$ using weight limit $w$ Case 2 : $OPT(i,w)$ selects item $i$ new weight limit $&#x3D; w-w_i$ OPT selects best of ${ 1, 2, \\cdots, i-1 }$ using this new weight limit $$ OPT(i,w)=\\left\\{\\begin{array}{l} &0 &\\text{if }i=0\\\\ &OPT(i-1,w) &\\text{if }w_i>w\\\\ &\\max{\\{OPT(i-1,w),v_i+OPT(i-1, w-w_i) \\}} &\\text{otherwise} \\end{array}\\right. $$ 123456789101112Input: n, W, w(1),...,w(N), v(1),...,v(N)for w = 0 to W\tM[0, w] = 0for i = 1 to n\tfor w = 1 to W if (w(i) &gt; w) M[i, w] = M[i-1, w] else M[i, w] = max &#123;M[i-1, w], v(i) + M[i-1, w-w(i)]&#125;return M[n, W] RNA Secondary Structure —— DP in intervalRNA. String $B &#x3D; b_1b_2\\cdots b_n$ over alphabet ${ A, C, G, U }$. Secondary structure. A set of pairs $S &#x3D; { (b_i, b_j) }$ that satisfy: [Watson-Crick.] $S$ is a matching and each pair in $S$ is a Watson- Crick complement: $A-U$, $U-A$, $C-G$, or $G-C$. [No sharp turns.] The ends of each pair are separated by at least 4 intervening bases. If $(b_i, b_j) \\in S$, then $i &lt; j - 4$. [Non-crossing.] If $(b_i, b_j)$ and $(b_k , b_l)$ are two pairs in $S$, then we cannot have $i$ Goal. Given an RNA molecule $B &#x3D; b_1b_2\\cdots b_n$ , find a secondary structure $S$ that maximizes the number of base pairs. 1234567RNA(b1,...,bn) &#123;\tfor k = 5, 6, ..., n-1 for i = 1, 2, ..., n-k j = i + k Compute M[i, j]\treturn M[1, n]&#125; Runtime: $O(n^3)$ (Compute needs O(n) ) Sequence AlignmentGoal. Find the minimum cost of aligning string $X&#x3D;x_1x_2\\cdots x_i$ and string $Y&#x3D;y_1y_2\\cdots y_j$ Runtime: $O(nm)$ Then how to reduce time ? e.g. $O(m+n)$ Use DP to store $f(i,j)$ (cost before point $(i,j)$) and $g(i,j)$ (after) Use Divide and Conquer Shortest Path To the whole graph, if applying dijestra, may lead to local optimal. Use Bellman-Ford 12345678910111213141516171819Push-Based-Shortest-Path(G, s, t) &#123;\tforeach node v in V &#123; M[v] &lt;- infty successor[v] &lt;- \\theta\t&#125;\tM[t] = 0\tfor i = 1 to n-1 &#123; foreach node w in V &#123; if (M[w] has been updated in previous iteration) &#123; foreach node v such that (v, w) in E &#123; if (M[v] &gt; M[w] + c(v,w)) &#123; M[v] &lt;- M[w] + c(v,w) successor[v] &lt;- w &#125; &#125; &#125; if no M[w] value changed in iteration i, stop.\t&#125;&#125; VII. Network Flow (Graph Problems)Minimum Cut Problem $G &#x3D; (V, E) &#x3D;$ directed graph, no parallel edges. Two distinguished nodes: $s &#x3D;$ source, $t &#x3D;$ sink. $c(e) &#x3D;$ capacity of edge $e$. Def. An s-t cut is a partition $(A, B)$ of $V$ with $s \\in A$ and $t \\in B$. Def. The capacity of a cut $(A, B)$ is: $cap(A,B)&#x3D;\\sum_{\\text{e out of A}} c(e)$ suppose only $s$ in $A$ , then $cap(A, B)&#x3D;10+5+15&#x3D;30$ Def. An s-t flow is a function that satisfies: For each $e\\in E$ : $0\\le f(e)\\le c(e)$ [capacity] For each $v\\in V-{s,t}$ : $\\sum_{\\text{e in v}}f(e)&#x3D;\\sum_{\\text{e out of v}}f(e)$ [conservation] The value of a flow $f$ is : $v(f)&#x3D;\\sum_{\\text{e out of s}}f(e)$ Pic below: $v(f)&#x3D;10+3+11&#x3D;24$ Max flow problem. Find s-t flow of maximum value Lemma. Let $f$ be any flow, and let $(A, B)$ be any s-t cut. Then, the net flow sent across the cut is equal to the amount leaving $s$$$\\sum_{e \\text{ out of }A}f(e)-\\sum_{e \\text{ in to }A}f(e)&#x3D;v(f)$$ Towards a Max Flow Algorithm —— Greedy Start with $f(e) &#x3D; 0$ for all edge $e \\in E$. Find an s-t path $P$ where each edge has $f(e) &lt; c(e)$. Augment flow along path $P$. Repeat until you get stuck. Problems: may got locally optimal when getting stuck. Solution —— get residual graph firstly (you’ll know how this is useful) Residual Edge : “Undo” flow sent for two node $u$ &amp; $v$, get forward edge $e(u,v)$ and backward edge $e^R(v, u)$ Residual capacity: $$c_f(e)&#x3D;\\left{ \\begin{array}{l}\\begin{align}&amp;c(e)-f(e)&amp; &amp;\\text{if }e\\in E\\&amp;f(e)&amp; &amp;\\text{if }e^R \\in E\\\\end{align}\\end{array}\\right.$$ Residual Graph: $G(V,E_f)$. Residual edges with positive residual capacity. $E_f &#x3D; {e : f(e) &lt; c(e)} \\cup {e^R : f(e) &gt; 0}$. Def. An augmenting path is a simple s→t path in the residual graph $G_f$ Def. The bottleneck capacity of an augmenting path $P$ is the minimum residual capacity of any edge in $P$ Key property. Let $f$ be a flow and let $P$ be an augmenting path in $G_f$ , then after calling $f’ \\leftarrow$ Augment$(f,c,P)$, the resulting $f’$ is flow and $v(f’) &#x3D; v(f) + \\text{bottleneck}(G_f ,P)$ Then apply Ford-Fulkerson Algorithm (pending…) There’s a problem: how to choose good augmenting path ? Choose augmenting paths with: Max bottleneck capacity (“fattest”). $\\leftarrow$ how to find? Sufficiently large bottleneck capacity. $\\leftarrow$ next Fewest edges. $\\leftarrow$ ahead Applying Capacity-Scaling Algorithm Overview. Choosing augmenting paths with “large” bottleneck capacity. Maintain scaling parameter $∆$. Let $G_f(∆)$ be the part of the residual graph containing only those edges with capacity $≥ ∆$. Any augmenting path in $G_f(∆)$ has bottleneck capacity $≥ ∆$ Bipartite Matchin How to use Maximum Flow ?","tags":["原创"],"categories":["Java","CSE Learning"]},{"title":"test_article","path":"/2024/06/07/test-article/","content":"这是一篇测试文章","tags":["原创"],"categories":["Java"]},{"title":"Introduction to Hexo and Github Page","path":"/2024/06/07/hello-world/","content":"Welcome to Hexo! This is the very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]